package lsc.jdk.concurrent.cas;

public class CasRead {
    /**
     * AS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。
     * 
     * 否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该
     * 
     * 位置的值。 （在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V 应该包含值 A； 如果包含该值，则将 B
     * 
     * 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”
     * 
     * 通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。
     * 
     * 类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。
     * 
     * 
     * 二、CAS的目的
     * 
     * 利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，
     * 
     * 因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。
     * 
     * 三、CAS存在的问题
     * 
     * 
     * CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作
     * 
     * 1. ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，
     * 
     * 那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。
     * 
     * ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。
     * 
     * 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。
     * 
     * 这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，
     * 
     * 如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
     */
}
